{
	"compiler": {
		"version": "0.8.24+commit.e11b9ed9"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "newAdmin",
						"type": "tuple"
					}
				],
				"name": "addCollectionAdminCross",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "user",
						"type": "tuple"
					}
				],
				"name": "addToCollectionAllowListCross",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "user",
						"type": "tuple"
					}
				],
				"name": "allowlistedCross",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "newOwner",
						"type": "tuple"
					}
				],
				"name": "changeCollectionOwnerCross",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "collectionAdmins",
				"outputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress[]",
						"name": "",
						"type": "tuple[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "collectionLimits",
				"outputs": [
					{
						"components": [
							{
								"internalType": "enum CollectionLimitField",
								"name": "field",
								"type": "uint8"
							},
							{
								"components": [
									{
										"internalType": "bool",
										"name": "status",
										"type": "bool"
									},
									{
										"internalType": "uint256",
										"name": "value",
										"type": "uint256"
									}
								],
								"internalType": "struct OptionUint256",
								"name": "value",
								"type": "tuple"
							}
						],
						"internalType": "struct CollectionLimit[]",
						"name": "",
						"type": "tuple[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "collectionNestingPermissions",
				"outputs": [
					{
						"components": [
							{
								"internalType": "enum CollectionPermissionField",
								"name": "field",
								"type": "uint8"
							},
							{
								"internalType": "bool",
								"name": "value",
								"type": "bool"
							}
						],
						"internalType": "struct CollectionNestingPermission[]",
						"name": "",
						"type": "tuple[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "collectionNestingRestrictedCollectionIds",
				"outputs": [
					{
						"components": [
							{
								"internalType": "bool",
								"name": "token_owner",
								"type": "bool"
							},
							{
								"internalType": "uint256[]",
								"name": "ids",
								"type": "uint256[]"
							}
						],
						"internalType": "struct CollectionNesting",
						"name": "",
						"type": "tuple"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "collectionOwner",
				"outputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "",
						"type": "tuple"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "string[]",
						"name": "keys",
						"type": "string[]"
					}
				],
				"name": "collectionProperties",
				"outputs": [
					{
						"components": [
							{
								"internalType": "string",
								"name": "key",
								"type": "string"
							},
							{
								"internalType": "bytes",
								"name": "value",
								"type": "bytes"
							}
						],
						"internalType": "struct Property[]",
						"name": "",
						"type": "tuple[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "string",
						"name": "key",
						"type": "string"
					}
				],
				"name": "collectionProperty",
				"outputs": [
					{
						"internalType": "bytes",
						"name": "",
						"type": "bytes"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "collectionSponsor",
				"outputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "",
						"type": "tuple"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "confirmCollectionSponsorship",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "contractAddress",
				"outputs": [
					{
						"internalType": "address",
						"name": "",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "string[]",
						"name": "keys",
						"type": "string[]"
					}
				],
				"name": "deleteCollectionProperties",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "hasCollectionPendingSponsor",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "user",
						"type": "tuple"
					}
				],
				"name": "isOwnerOrAdminCross",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "admin",
						"type": "tuple"
					}
				],
				"name": "removeCollectionAdminCross",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "removeCollectionSponsor",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "user",
						"type": "tuple"
					}
				],
				"name": "removeFromCollectionAllowListCross",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "enum AccessMode",
						"name": "mode",
						"type": "uint8"
					}
				],
				"name": "setCollectionAccess",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "enum CollectionLimitField",
								"name": "field",
								"type": "uint8"
							},
							{
								"components": [
									{
										"internalType": "bool",
										"name": "status",
										"type": "bool"
									},
									{
										"internalType": "uint256",
										"name": "value",
										"type": "uint256"
									}
								],
								"internalType": "struct OptionUint256",
								"name": "value",
								"type": "tuple"
							}
						],
						"internalType": "struct CollectionLimit",
						"name": "limit",
						"type": "tuple"
					}
				],
				"name": "setCollectionLimit",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bool",
						"name": "mode",
						"type": "bool"
					}
				],
				"name": "setCollectionMintMode",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bool",
						"name": "enable",
						"type": "bool"
					}
				],
				"name": "setCollectionNesting",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bool",
						"name": "enable",
						"type": "bool"
					},
					{
						"internalType": "address[]",
						"name": "collections",
						"type": "address[]"
					}
				],
				"name": "setCollectionNesting",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "string",
								"name": "key",
								"type": "string"
							},
							{
								"internalType": "bytes",
								"name": "value",
								"type": "bytes"
							}
						],
						"internalType": "struct Property[]",
						"name": "properties",
						"type": "tuple[]"
					}
				],
				"name": "setCollectionProperties",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"components": [
							{
								"internalType": "address",
								"name": "eth",
								"type": "address"
							},
							{
								"internalType": "uint256",
								"name": "sub",
								"type": "uint256"
							}
						],
						"internalType": "struct CrossAddress",
						"name": "sponsor",
						"type": "tuple"
					}
				],
				"name": "setCollectionSponsorCross",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes4",
						"name": "interfaceID",
						"type": "bytes4"
					}
				],
				"name": "supportsInterface",
				"outputs": [
					{
						"internalType": "bool",
						"name": "",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "uniqueCollectionType",
				"outputs": [
					{
						"internalType": "string",
						"name": "",
						"type": "string"
					}
				],
				"stateMutability": "view",
				"type": "function"
			}
		],
		"devdoc": {
			"details": "the ERC-165 identifier for this interface is 0x2a14cfd1",
			"kind": "dev",
			"methods": {
				"addCollectionAdminCross((address,uint256))": {
					"details": "EVM selector for this function is: 0x859aa7d6,  or in textual repr: addCollectionAdminCross((address,uint256))",
					"params": {
						"newAdmin": "Cross account administrator address."
					}
				},
				"addToCollectionAllowListCross((address,uint256))": {
					"details": "EVM selector for this function is: 0xa0184a3a,  or in textual repr: addToCollectionAllowListCross((address,uint256))",
					"params": {
						"user": "User cross account address."
					}
				},
				"allowlistedCross((address,uint256))": {
					"details": "EVM selector for this function is: 0x91b6df49,  or in textual repr: allowlistedCross((address,uint256))",
					"params": {
						"user": "User address to check."
					}
				},
				"changeCollectionOwnerCross((address,uint256))": {
					"details": "Owner can be changed only by current ownerEVM selector for this function is: 0x6496c497,  or in textual repr: changeCollectionOwnerCross((address,uint256))",
					"params": {
						"newOwner": "new owner cross account"
					}
				},
				"collectionAdmins()": {
					"details": "EVM selector for this function is: 0x5813216b,  or in textual repr: collectionAdmins()",
					"returns": {
						"_0": "Vector of tuples with admins address and his substrate mirror. If address is canonical then substrate mirror is zero and vice versa."
					}
				},
				"collectionLimits()": {
					"details": "EVM selector for this function is: 0xf63bc572,  or in textual repr: collectionLimits()",
					"returns": {
						"_0": "Array of collection limits"
					}
				},
				"collectionNestingPermissions()": {
					"details": "EVM selector for this function is: 0x5b2eaf4b,  or in textual repr: collectionNestingPermissions()"
				},
				"collectionNestingRestrictedCollectionIds()": {
					"details": "EVM selector for this function is: 0x22d25bfe,  or in textual repr: collectionNestingRestrictedCollectionIds()"
				},
				"collectionOwner()": {
					"details": "EVM selector for this function is: 0xdf727d3b,  or in textual repr: collectionOwner()",
					"returns": {
						"_0": "Tuble with sponsor address and his substrate mirror. If address is canonical then substrate mirror is zero and vice versa."
					}
				},
				"collectionProperties(string[])": {
					"details": "EVM selector for this function is: 0x285fb8e6,  or in textual repr: collectionProperties(string[])",
					"params": {
						"keys": "Properties keys. Empty keys for all propertyes."
					},
					"returns": {
						"_0": "Vector of properties key/value pairs."
					}
				},
				"collectionProperty(string)": {
					"details": "Throws error if key not found.EVM selector for this function is: 0xcf24fd6d,  or in textual repr: collectionProperty(string)",
					"params": {
						"key": "Property key."
					},
					"returns": {
						"_0": "bytes The property corresponding to the key."
					}
				},
				"collectionSponsor()": {
					"details": "EVM selector for this function is: 0x6ec0a9f1,  or in textual repr: collectionSponsor()",
					"returns": {
						"_0": "Tuble with sponsor address and his substrate mirror. If there is no confirmed sponsor error \"Contract has no sponsor\" throw."
					}
				},
				"confirmCollectionSponsorship()": {
					"details": "After setting the sponsor for the collection, it must be confirmed with this function.EVM selector for this function is: 0x3c50e97a,  or in textual repr: confirmCollectionSponsorship()"
				},
				"contractAddress()": {
					"details": "EVM selector for this function is: 0xf6b4dfb4,  or in textual repr: contractAddress()"
				},
				"deleteCollectionProperties(string[])": {
					"details": "EVM selector for this function is: 0xee206ee3,  or in textual repr: deleteCollectionProperties(string[])",
					"params": {
						"keys": "Properties keys."
					}
				},
				"hasCollectionPendingSponsor()": {
					"details": "EVM selector for this function is: 0x058ac185,  or in textual repr: hasCollectionPendingSponsor()"
				},
				"isOwnerOrAdminCross((address,uint256))": {
					"details": "EVM selector for this function is: 0x3e75a905,  or in textual repr: isOwnerOrAdminCross((address,uint256))",
					"params": {
						"user": "User cross account to verify"
					},
					"returns": {
						"_0": "\"true\" if account is the owner or admin"
					}
				},
				"removeCollectionAdminCross((address,uint256))": {
					"details": "EVM selector for this function is: 0x6c0cd173,  or in textual repr: removeCollectionAdminCross((address,uint256))",
					"params": {
						"admin": "Cross account administrator address."
					}
				},
				"removeCollectionSponsor()": {
					"details": "EVM selector for this function is: 0x6e0326a3,  or in textual repr: removeCollectionSponsor()"
				},
				"removeFromCollectionAllowListCross((address,uint256))": {
					"details": "EVM selector for this function is: 0x09ba452a,  or in textual repr: removeFromCollectionAllowListCross((address,uint256))",
					"params": {
						"user": "User cross account address."
					}
				},
				"setCollectionAccess(uint8)": {
					"details": "EVM selector for this function is: 0x41835d4c,  or in textual repr: setCollectionAccess(uint8)",
					"params": {
						"mode": "Access mode"
					}
				},
				"setCollectionLimit((uint8,(bool,uint256)))": {
					"details": "Throws error if limit not found.EVM selector for this function is: 0x2316ee74,  or in textual repr: setCollectionLimit((uint8,(bool,uint256)))",
					"params": {
						"limit": "Some limit."
					}
				},
				"setCollectionMintMode(bool)": {
					"details": "EVM selector for this function is: 0x00018e84,  or in textual repr: setCollectionMintMode(bool)",
					"params": {
						"mode": "Enable if \"true\"."
					}
				},
				"setCollectionNesting(bool)": {
					"details": "EVM selector for this function is: 0x112d4586,  or in textual repr: setCollectionNesting(bool)",
					"params": {
						"enable": "If \"true\" degenerates to nesting: 'Owner' else to nesting: 'Disabled'"
					}
				},
				"setCollectionNesting(bool,address[])": {
					"details": "EVM selector for this function is: 0x64872396,  or in textual repr: setCollectionNesting(bool,address[])",
					"params": {
						"collections": "Addresses of collections that will be available for nesting.",
						"enable": "If \"true\" degenerates to nesting: {OwnerRestricted: [1, 2, 3]} else to nesting: 'Disabled'"
					}
				},
				"setCollectionProperties((string,bytes)[])": {
					"details": "EVM selector for this function is: 0x50b26b2a,  or in textual repr: setCollectionProperties((string,bytes)[])",
					"params": {
						"properties": "Vector of properties key/value pair."
					}
				},
				"setCollectionSponsorCross((address,uint256))": {
					"details": "In order for sponsorship to work, it must be confirmed on behalf of the sponsor.EVM selector for this function is: 0x84a1d5a8,  or in textual repr: setCollectionSponsorCross((address,uint256))",
					"params": {
						"sponsor": "Cross account address of the sponsor from whose account funds will be debited for operations with the contract."
					}
				},
				"uniqueCollectionType()": {
					"details": "EVM selector for this function is: 0xd34b55b8,  or in textual repr: uniqueCollectionType()",
					"returns": {
						"_0": "`Fungible` or `NFT` or `ReFungible`"
					}
				}
			},
			"title": "A contract that allows you to work with collections.",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"addCollectionAdminCross((address,uint256))": {
					"notice": "Add collection admin."
				},
				"addToCollectionAllowListCross((address,uint256))": {
					"notice": "Add user to allowed list."
				},
				"allowlistedCross((address,uint256))": {
					"notice": "Checks that user allowed to operate with collection."
				},
				"changeCollectionOwnerCross((address,uint256))": {
					"notice": "Changes collection owner to another account"
				},
				"collectionAdmins()": {
					"notice": "Get collection administrators"
				},
				"collectionLimits()": {
					"notice": "Get current collection limits."
				},
				"collectionNestingPermissions()": {
					"notice": "Returns permissions for a collection"
				},
				"collectionNestingRestrictedCollectionIds()": {
					"notice": "Returns nesting for a collection"
				},
				"collectionOwner()": {
					"notice": "Get collection owner."
				},
				"collectionProperties(string[])": {
					"notice": "Get collection properties."
				},
				"collectionProperty(string)": {
					"notice": "Get collection property."
				},
				"collectionSponsor()": {
					"notice": "Get current sponsor."
				},
				"confirmCollectionSponsorship()": {
					"notice": "Collection sponsorship confirmation."
				},
				"contractAddress()": {
					"notice": "Get contract address."
				},
				"deleteCollectionProperties(string[])": {
					"notice": "Delete collection properties."
				},
				"hasCollectionPendingSponsor()": {
					"notice": "Whether there is a pending sponsor."
				},
				"isOwnerOrAdminCross((address,uint256))": {
					"notice": "Check that account is the owner or admin of the collection"
				},
				"removeCollectionAdminCross((address,uint256))": {
					"notice": "Remove collection admin."
				},
				"removeCollectionSponsor()": {
					"notice": "Remove collection sponsor."
				},
				"removeFromCollectionAllowListCross((address,uint256))": {
					"notice": "Remove user from allowed list."
				},
				"setCollectionAccess(uint8)": {
					"notice": "Set the collection access method."
				},
				"setCollectionLimit((uint8,(bool,uint256)))": {
					"notice": "Set limits for the collection."
				},
				"setCollectionMintMode(bool)": {
					"notice": "Switch permission for minting."
				},
				"setCollectionNesting(bool)": {
					"notice": "Toggle accessibility of collection nesting."
				},
				"setCollectionNesting(bool,address[])": {
					"notice": "Toggle accessibility of collection nesting."
				},
				"setCollectionProperties((string,bytes)[])": {
					"notice": "Set collection properties."
				},
				"setCollectionSponsorCross((address,uint256))": {
					"notice": "Set the sponsor of the collection."
				},
				"uniqueCollectionType()": {
					"notice": "Returns collection type"
				}
			},
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"contracts/UniqueNFT.sol": "Collection"
		},
		"evmVersion": "shanghai",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"contracts/UniqueNFT.sol": {
			"keccak256": "0xc148492110ebeaac4699ffeac8dd74d1629204d70948653256ded15c2b1f5d06",
			"license": "OTHER",
			"urls": [
				"bzz-raw://dc6f720c79f4c8807e4043592ebaa23566e400d79d312bf5afa4e6a4cae8ff82",
				"dweb:/ipfs/QmNkDq6rVBiDEw5NpP3JfjheUqEY6QAy9Vc7emGsnvr8X8"
			]
		}
	},
	"version": 1
}